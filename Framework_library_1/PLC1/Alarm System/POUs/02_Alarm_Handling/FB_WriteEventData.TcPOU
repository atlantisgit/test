<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.9">
  <POU Name="FB_WriteEventData" Id="{e957b03b-31be-405b-ab3a-a49e3431ecd4}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_WriteEventData
(**********************************************************************************)
(**********************************************************************************)
(*  	VERSION:			002.012
							                									
	PROGRAMMED BY:	Puja					  					
  	Changed by:			Hardy Patommel							
*)  																		
(*-----------------------------------------------------------------------------------------------------------------------------------*)
(*  REVISIONS:						                							 
   	Date		|	Version/Author 	|	Remark
	----------------------------------------------------------------------------------------------------
	2007-10-08	|	001.001     HP		|   	formatting the REAL value FOR the file output
	2008-03-04	|	002.000     HP		|   	add header function block
	2008-03-27	|	002.001     HP		|   	add header length with initialization value
	2009-03-26	|	002.010     HP		|   	get header length as parameter
	2009-03-27	|	002.011     HP		|   	change strBuffer size with a constant variable
	2009-08-09	|	002.012     HP		|   	change sTimestamp[24]
*)
(*-----------------------------------------------------------------------------------------------------------------------------------*)
(*  	DESCRIPTION:
	Constant value for the file layout >>	
		nNextPointerLoc			: DINT;		>>> actual position for the next entry [NOVRAM]
		iFirstHeaderLEN1			: INT:=1000;	>>> header size without column-description

	Note:
		 iFirstHeaderLEN and iColumnLineLEN are only necessary when the data file will be create
*)
(**********************************************************************************)
(**********************************************************************************)
VAR_INPUT
	bExecute 				: BOOL;
	sNetId					: T_AmsNetId;
	sPathName				: T_MaxString;
	dwTransferBufferStartAdr	: DWORD;
	iNewValues				: INT;
	udNumberofValues 		: UDINT;
	udNumberOfEventDatas	: UDINT;
	udArrDataSize			: ARRAY [1..NUMBER_OF_EVENT_DATAS] OF UDINT;
	eDataType				: ARRAY [1..NUMBER_OF_EVENT_DATAS] OF E_DataType;
	sHeaderOfEventData	: ARRAY [1..giGeneralLoggerChannelInUsed] OF STRING(giGeneralLenghtOfName);
	iHeaderLEN				: INT;  (*length of whole header; first header + column*)
END_VAR
VAR_IN_OUT
	nNextPointerLoc			: DINT;
END_VAR
VAR_OUTPUT
	udValuesWritten			: UDINT;
	bBusy					: BOOL;
	bDone					: BOOL;
	bError					: BOOL;
	nErrId					: UDINT;
END_VAR
VAR
	RExec_Trig				: R_TRIG;
	hFile					: UINT;
	fbFileOpen				: FB_FileOpen;
	fbFileSeek				: FB_FileSeek;
	fbFileWrite				: FB_FileWrite;
	fbFileClose				: FB_FileClose;
	tAdsTimeOut			: TIME:= T#10s;
	eFileState				: E_FileState_SC;
	nMode					: DWORD;
	sStrBuffer				: STRING(guiStrBufferSize);	(* header 1100 + row 200 * 218 sign = 44700*)
	sStrHeader				: STRING(2170);	 	(*10 row with 217 sign*)
	sVar					: STRING(255);
	sHeader					: STRING(giHeaderColumnLineLEN); (*:='TimeStampUTC$TTrigKey$TUserName$TBrakeProgram$T'; (*!!HP*)		DISABLED BY NIHAL MALIK *)
	sTab					: STRING[2] := '$T';
	sLineFeed				: STRING[4] := '$R$N';

	i						: INT;


	dwCaptureTransferBufferStartAdr : DWORD;
	sTimeStamp			: STRING[24];	(* Time the Statuscode becomes true *)
	sTrigEvent				: STRING[guiKeyAndTextLen];	(* key and Text of Statuscode, like sKeyAndText[80] in M_AddEvent*)
	sUserName				: STRING[24];	(* name of the user who had the Active Status to do the operation *)
	sBrakeProgram			: STRING[4]; 	(* Activated brake program *)
	rVar						: REAL;
(*	eTime					:= 12,
	eDate					:= 13,
	eTime_OF_Day			:= 14,
	eDateAndTime			:= 15,
	eString					:= 16,	*)
	iCopyOffset				: INT;

	iPrepIndex				: INT;
	iStrBufferIdx				: UINT; (*Index buffer*)

	iStrLineIdx				: INT; (*Index line*)
	iStuff					: INT;
	iStartStuffIndex			: INT;
	iEndStuffIndex			: INT;
	iStartIndex				: INT;
	iEndIndex				: INT;

	iBatchValue				: INT := 20;(* in batch of how many entries is the data to be written *)
	iEventsWrittenCurrent		: INT;		(* Event written in current cycle *)
	iCaptureNewValues		: INT;		(* captures new values *)
	iEntriesWritten			: INT;		(* Entries Written; so as to calculate the next pointer location*)
	iFittingEntries				: INT;		(* number of entries fitting *)
	iEventsInCycle			: INT;		(* In how many batches is data written *)
	bHeader					: BOOL;		(* If a new file write then to write the header *)
	iCounter					: INT;		(* Total number of entries written till now, so as to tally *)
	iNumberOfEventDatas		: INT;
	sTimestampShort			: STRING[12];
	sRealDataReduce		: STRING[10];
	iLength					: INT;
	iDiffenzLength				: INT;
	iForIndex					: UINT;

	fbHeaderForLogging		: FB_HeaderForLogging;
	iFirstHeaderLEN			: INT;
	iColumnLineLEN		: INT;
	uiCountsOfLine			: UINT;
	udiCheckHeaderLength	: UDINT;

END_VAR

]]></Declaration>
    <Implementation>
      <ST><![CDATA[(*========== START OF FUNCTION_BLOCK / PROGRAMM ============*)


(*=====================================================================*)
(*					write event data to file        							     *)
(*=====================================================================*)
RExec_Trig( CLK := bExecute );

CASE eFileState OF
   eInit_SC:
		IF RExec_Trig.Q THEN	(* Rising edge triggered *)
			bBusy 	:= TRUE;
			bError	:= FALSE;
			bDone 	:= FALSE;
			nErrId	:= 0;
			hFile	:= 0;

			dwCaptureTransferBufferStartAdr := dwTransferBufferStartAdr;(* capture the transfer buffer address *)
			iCaptureNewValues	:= iNewValues;					(* make a copy of the input newvalues *)
			iNumberOfEventDatas := UDINT_TO_INT(udNumberOfEventDatas);
			nMode := FOPEN_MODEREAD OR FOPEN_MODEPLUS OR FOPEN_MODEBINARY;
			(*nMode := FOPEN_MODEAPPEND OR FOPEN_MODEPLUS OR FOPEN_MODEBINARY;*)
			iBatchValue := (guiStrBufferSize/iOneEntryLength) - 1;		(* calculate the batch size in which data is to be written *)
			IF iCaptureNewValues > 0 THEN
				sTimestampShort :='4';(* FUN_TimeToString(Lib_strucSystemTime); (*access time *)TO ACTION*)
				(* Open a file *)
				fbFileOpen( bExecute	:= FALSE	);
				fbFileOpen(	bExecute	:= TRUE,
							sNetId		:= sNetID,
							sPathName	:=sPathName,
							nMode		:= nMode,
							ePath		:= Path_Generic,
							tTimeout	:= tAdsTimeOut );

				eFileState := eFileOpen_SC;
				(* reset the variables *)
				iStartIndex := 1;
				iStrBufferIdx := 0;
				sStrBuffer := '';
				sVar := '';
				udValuesWritten := 0;
			END_IF
		END_IF

		g_TriggSendExeAlarmList := FALSE;

	eFileOpen_SC:	(* Wait for the file to be opened *)
		fbFileOpen( );
		IF NOT fbFileOpen.bBusy THEN
			fbFileOpen(	bExecute := FALSE);

			IF NOT fbFileOpen.bError THEN		(* if no error; File already exists *)

				IF NOT bHeader AND nNextPointerLoc > 0 THEN		(*Check the next pointer persistent value*)
					nNextPointerLoc := nNextPointerLoc -  iHeaderLEN;
					IF  iOneEntryLength <> 0 THEN
						iEntriesWritten := DINT_TO_INT(nNextPointerLoc/iOneEntryLength);
						iCounter := DINT_TO_INT(nNextPointerLoc/iOneEntryLength);
					END_IF

					nNextPointerLoc := nNextPointerLoc + iHeaderLEN;

				ELSIF bHeader THEN		(* if file did not exist then iEntriesWritten to beginning *)
					iEntriesWritten := 0;
					iCounter := 0;
				ELSIF NOT bHeader AND (nNextPointerLoc = 0) THEN	(* reset all and file exist *)
					nNextPointerLoc := nNextPointerLoc + iHeaderLEN;
				END_IF
				iFittingEntries := UDINT_TO_INT(udNumberofValues)  - iEntriesWritten ;
				(* calculate the minimum of Captured values, Batch value and how many can fit *)
				iEndIndex := MIN(iCaptureNewValues,iBatchValue);
				iEventsWrittenCurrent := iEndIndex := MIN(iEndIndex, iFittingEntries);

				hFile  := fbFileOpen.hFile;
				fbFileSeek( bExecute := FALSE);			(* File Seek *)
				fbFileSeek(	sNetId 		:= sNetId,
							hFile		:= hFile,
							nSeekPos	:= nNextPointerLoc,			(* File pointer to zero *)
							eOrigin		:= SEEK_SET,
							bExecute	:= TRUE,
							tTimeout	:= tAdsTimeOut,
							);
				eFileState := eFileSeek_SC;

			ELSE	(*if error, File does not exist; a new file is to be written *)

				(*create new file with header*)
				nMode := FOPEN_MODEWRITE  OR FOPEN_MODEPLUS OR FOPEN_MODEBINARY;
				(*nMode := FOPEN_MODEAPPEND  OR FOPEN_MODEPLUS OR FOPEN_MODEBINARY;*)
				fbFileOpen( bExecute	:= FALSE	);
				fbFileOpen(	bExecute	:= TRUE,
				 			sNetId		:= sNetID,
							sPathName	:= sPathName,
							nMode		:= nMode,
							ePath		:= Path_Generic,
							tTimeout	:= tAdsTimeOut );
				eFileState := eFileOpen_SC;
				nNextPointerLoc := 0;
				iCounter := 0;
				(* if new file is being written then write down the header *)
				bHeader := TRUE;

				fbHeaderForLogging(
						st_TurbineIdent		:= st_xTurbineIdent ,			(*general machine info*)
						s_FileDescription	:= fbSCLogger.stFileSetup.sFileDescription,
						s_ColumnText 		:= gstrRingBufferFileColumnText,
						ar_ColumnText		:= sHeaderOfEventData,		(*array of column description*)
						iCountsOfColumns	:= iNumberOfEventDatas,	(*counts of columns*)
						iOneEntryLength	:= giRingBufferFileOneEntryLength,(*length of every entry, all lines with the same length, see init-logger*)
				//ACTION		adr_sHeader1		:= ADR(sStrHeader) ,		(*part one of the header*)
				//ACTION		adr_sColumnLine	:= ADR(sHeader),			(*part two of the header*)
						iCountsOfLine		=> uiCountsOfLine,			(*lines of the part one header*)
						iHeaderLEN			=> iFirstHeaderLEN,			(*length of the part one header*)
						iColumnLineLEN	=> iColumnLineLEN);		(*length of the part two header*)


				(*Check the header length: header and column-description*)
				udiCheckHeaderLength := LEN(sStrHeader) + LEN(sHeader);
			END_IF
		END_IF


	eFileSeek_SC:
		fbFileSeek( );
		IF NOT fbFileSeek.bBusy THEN
			fbFileSeek(bExecute := FALSE );
			IF NOT fbFileSeek.bError THEN

				(* Prepare the data to be written *)
				M_PrepareWriteData( );

				(* Write into File *)
				fbFileWrite( 	bExecute	:= FALSE	);
				fbFileWrite(  	bExecute	:= TRUE,
								sNetId		:= sNetID,
								hFile		:= hFile,
								pWriteBuff	:= ADR(sStrBuffer),
								cbWriteLen	:= iStrBufferIdx,         (*Write not the whole Buffer, only new entries*)
								tTimeout	:= tAdsTimeOut	);

				iStrBufferIdx := iStrBufferIdx;

				eFileState := eFileWrite_SC;

			ELSE
				bBusy := FALSE;
				bError := TRUE;
				nErrId := fbFileSeek.nErrId;
				eFileState := eInit_SC;
			END_IF
		END_IF


	eFileWrite_SC:	(* Wait until  the file is written *)
		fbFileWrite();
		IF NOT fbFileWrite.bBusy THEN
			fbFileWrite(bExecute := FALSE);
			IF NOT fbFileWrite.bError THEN
				bHeader := FALSE;
				IF iCaptureNewValues > iEventsWrittenCurrent THEN		(* data is to be written into two or more parts *)
					IF iEventsWrittenCurrent = iBatchValue THEN
						(* sStrBuffer was insufficient to occupy all entries, Fitting entries were greater than that, continue writting at same file pointer *)
						iEntriesWritten := iEntriesWritten + iBatchValue;
						iFittingEntries := iFittingEntries - iEventsWrittenCurrent;
						iCaptureNewValues := iCaptureNewValues - iEventsWrittenCurrent;
						iEndIndex := MIN( iCaptureNewValues , iBatchValue);
						iEventsWrittenCurrent := iEndIndex := MIN( iEndIndex , iFittingEntries); (* Events to be written in current write cycle;*)
						iStrBufferIdx := 0;				(* reset while new batch write *)

						(* Prepare the next batch of data to be written *)
						M_PrepareWriteData( );

						(* Write into File *)
						fbFileWrite( 	bExecute	:= FALSE	);
						fbFileWrite(  	bExecute	:= TRUE,
								sNetId		:= sNetID,
								hFile		:= hFile,
								pWriteBuff	:= ADR(sStrBuffer),
								cbWriteLen	:= iStrBufferIdx,         (*Write not the whole Buffer, only new entries*)
								tTimeout	:= tAdsTimeOut	);

						iStrBufferIdx := iStrBufferIdx;
						eFileState := eFileWrite_SC;

					ELSIF iEventsWrittenCurrent = iFittingEntries THEN
						(* if the events written was just fit; pointer location to be set to beginning of file *)
						(* -------------------------------------------------------------------------------------------------------------*)
						iEntriesWritten := 0;
						iFittingEntries := UDINT_TO_INT(udNumberofValues);		(* go to beginning of file and initialise fitting entries to max *)
						iCaptureNewValues := iCaptureNewValues - iEventsWrittenCurrent;
						iEventsWrittenCurrent := iEndIndex := MIN( iCaptureNewValues , iBatchValue);
						iStrBufferIdx := 0;

						(* calculate the next pointer location *)
						nNextPointerLoc := iHeaderLEN + (iEntriesWritten * iOneEntryLength);
						fbFileSeek( bExecute := FALSE);			(* File Seek *)
						fbFileSeek(	sNetId 		:= sNetId,
									hFile		:= hFile,
									nSeekPos	:= nNextPointerLoc,	(* File pointer to next loc - first line in file*)
									eOrigin		:= SEEK_SET,
									bExecute	:= TRUE,
									tTimeout	:= tAdsTimeOut
									);
						eFileState := eFileSeek_SC;
					END_IF

				ELSE	(* if exact fit then reintialise pointer to start of file *)
						(* ------------------------------------------------------------------*)
					IF iFittingEntries = iCaptureNewValues THEN
						iEntriesWritten := 0; (* actually 200 but reset to 1 *)
					ELSE
						iEntriesWritten := iEntriesWritten + iCaptureNewValues;
					END_IF
					nNextPointerLoc :=iHeaderLEN + ( iEntriesWritten * iOneEntryLength);
					(* Close the File *)
					fbFileClose(	bExecute:= FALSE	);
					fbFileClose(	bExecute:= TRUE,
									sNetId	:= sNetID,
									hFile	:= hFile,
									tTimeout:= tAdsTimeOut	);
					eFileState := eFileClose_SC;
				END_IF
			ELSE
				bBusy := FALSE;
				bError := TRUE;
				nErrId := fbFileWrite.nErrId;
				eFileState := eInit_SC;
			END_IF
		END_IF



	eFileClose_SC:	(* Wait untill File is closed *)
		fbFileClose();
		IF NOT fbFileClose.bBusy THEN
			fbFileClose( bExecute:= FALSE );
			IF NOT fbFileClose.bError THEN
				IF iCounter >= UDINT_TO_INT(udNumberOfValues) THEN
					iCounter := iCounter;
				END_IF
				(*eFileState := eInit_SC;*)
				eFileState := eFileCopy_SC;
				bBusy  := FALSE;
				bDone  := TRUE;
				bHeader := FALSE;
				sStrBuffer := '';
				iCaptureNewValues := 0;
				iEventsInCycle := 0;
			ELSE
				bBusy := FALSE;
				bError := TRUE;
				nErrId := fbFileClose.nErrId;
				eFileState := eInit_SC;
			END_IF
		END_IF

		eFileCopy_SC:
			g_TriggSendExeAlarmList := TRUE;
			eFileState := eInit_SC;

END_CASE

(*=========== END OF FUNCTION_BLOCK / PROGRAMM =============*)]]></ST>
    </Implementation>
    <Action Name="M_PrepareWriteData" Id="{898b40cc-12bd-4858-b7ac-da955ca17b4d}">
      <Implementation>
        <ST><![CDATA[MEMSET(ADR(sStrBuffer) , 0, LEN(sStrBuffer));
IF bHeader  THEN
	(*Header part one*)
	MEMCPY(ADR(sStrBuffer) ,ADR(sStrHeader),iFirstHeaderLEN);
	(*Header part two, column description*)
	MEMCPY(ADR(sStrBuffer)+iFirstHeaderLEN ,ADR(sHeader),iColumnLineLEN);
	(*index for buffer entry after the header; iHeaderLEN := iFirstHeaderLEN + iColumnLineLEN;*)
	iStrBufferIdx := iHeaderLEN;
	(* Write into File *)
END_IF

(* Stuff the data to be written into a string buffer *)
FOR iPrepIndex := iStartIndex  TO iEndIndex DO	(* for loop from new index value to the number of new values *)
	iCopyOffset := (((iPrepIndex-1)+iEventsInCycle)*iOneEntrySize); (*iCopyOffset := Offset in array ringbuffer*)
	sVar := '';
	iStrLineIdx := 0; (*index for the line, function stuff line*)
	(*gets the new dataset ####################*)
	(*gets timestamp value ---------------*)
	MEMCPY(
		ADR(sTimeStamp),
		dwCaptureTransferBufferStartAdr+iCopyOffset,
		SIZEOF(sTimeStamp));
	sVar := CONCAT('',sTimeStamp);
	sVar := CONCAT(sVar,sTab);
	iCopyOffset := iCopyOffset + SIZEOF(sTimeStamp);

	(*gets trigger event string ---------------*)
	MEMCPY(
		ADR(sTrigEvent),
		dwCaptureTransferBufferStartAdr+iCopyOffset,
		SIZEOF(sTrigEvent));
	(*look and fill to 50 sign*)
	iLength := LEN(sTrigEvent);
	IF (iLength<giCountsOfKeyLetterForStatuscodeFile) THEN
		iDiffenzLength := giCountsOfKeyLetterForStatuscodeFile - iLength ;
		FOR iForIndex := 1 TO  iDiffenzLength DO
			sTrigEvent := CONCAT(sTrigEvent,' ');
		END_FOR
	END_IF
	sTrigEvent := sTrigEvent ;
	sVar := CONCAT(sVar,sTrigEvent);
	sVar := CONCAT(sVar,sTab);
	iCopyOffset := iCopyOffset + SIZEOF(sTrigEvent); (*read data out of log-array*)

	(*gets user name string ---------------*)
	MEMCPY(
		ADR(sUserName),
		dwCaptureTransferBufferStartAdr+iCopyOffset,
		SIZEOF(sUserName));
	sVar := CONCAT(sVar,sUserName);
	sVar := CONCAT(sVar,sTab);
	iCopyOffset := iCopyOffset + SIZEOF(sUserName);

	(*gets brake program string ---------------*)
	MEMCPY(
		ADR(sBrakeProgram),
		dwCaptureTransferBufferStartAdr+iCopyOffset,
		SIZEOF(sBrakeProgram));
	sVar := CONCAT(sVar,sBrakeProgram);
	sVar := CONCAT(sVar,sTab);
	iCopyOffset := iCopyOffset + SIZEOF(sBrakeProgram);

	(*gets configuration data  value ---------------*)
	(* convert appropriate event datas into string format and concat into one string buffer *)
	FOR i := 1 TO iNumberOfEventDatas DO
		CASE eDataType[i] OF

			eReal :
				(*formatting the real value*)
				MEMCPY(ADR(rVar),dwCaptureTransferBufferStartAdr+iCopyOffset,udArrDataSize[i]);
				sRealDataReduce := '8'(*FUN_Real_to_string(rVar,2)*);

				sVar := CONCAT(sVar,sRealDataReduce);
				sVar := CONCAT(sVar,sTab);	(* append tab *)
				iCopyOffset := iCopyOffset + UDINT_TO_INT(udArrDataSize[i]) ;

		END_CASE
	END_FOR


	iStrLineIdx := LEN(sVar);			(*length of string in one row, prepared for file logging*)
	iStartStuffIndex := iStrLineIdx + 1;		(*start address for stuff sign*)
	iEndStuffIndex := iOneEntryLength-2;

	(* append spaces to make every event of same length *)
	IF iStrLineIdx < iEndStuffIndex THEN
		FOR iStuff := iStartStuffIndex TO  iEndStuffIndex DO
			sVar := CONCAT(sVar,' ');
			iStrLineIdx := iStrLineIdx + 1;
		END_FOR
	END_IF
	sVar := CONCAT(sVar,sLineFeed);			(* append line feed *)
	iStrLineIdx := iStrLineIdx + LEN(sLineFeed);	(*length of string in one row*)

	(* copy the event into the string buffer *)
	IF bHeader THEN
		MEMCPY(
			ADR(sStrBuffer)+ iHeaderLEN + (iOneEntryLength * (iPrepIndex - 1)) ,
			ADR(sVar),
			iOneEntryLength);
	ELSE
		MEMCPY(
			ADR(sStrBuffer)+ (iOneEntryLength * (iPrepIndex - 1)) ,
			ADR(sVar),
			iOneEntryLength);
	END_IF

	iStrBufferIdx := iStrBufferIdx + iOneEntryLength;
	iStrLineIdx := 0;
	iCounter := iCounter + 1;


END_FOR

udValuesWritten := udValuesWritten + iEndIndex;	(* output how many values already written *)
iEventsInCycle := iEventsInCycle + iEndIndex;		(* Calculate the number of events written / in how many batches *)]]></ST>
      </Implementation>
    </Action>
    <LineIds Name="FB_WriteEventData">
      <LineId Id="120" Count="262" />
    </LineIds>
    <LineIds Name="FB_WriteEventData.M_PrepareWriteData">
      <LineId Id="0" Count="115" />
    </LineIds>
  </POU>
</TcPlcObject>